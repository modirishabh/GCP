# Kubernetes Fundamentals

Kubernetes uses an object model and declarative management to orchestrate containers reliably. Objects represent cluster state, while the control plane continuously reconciles desired and actual states via a watch loop.  

This document explains these fundamentals, including **Pods** and **Google Kubernetes Engine (GKE)** simplifications.

---

## Core Concepts

Kubernetes objects are persistent entities that define the cluster state.  

- **spec**: Describes the desired configuration (e.g., three nginx Pods).  
- **status**: Reflects the current state, continuously updated by the control plane.  

**Declarative management** means you declare the goal, and Kubernetes ensures the system converges toward it.  
Controllers monitor the API server, detect changes, and act to maintain consistency — for example, launching missing Pods to match the declared spec.  

The **watch loop** continuously compares desired and actual states, performing necessary actions to reconcile them.

---

## Pods Explained

**Pods** are the smallest deployable units in Kubernetes.  

Each Pod can host one or more tightly coupled containers that share:  
- **Networking**: Single IP address, allowing localhost communication.  
- **Storage volumes**: Shared persistent data volumes.  
- **Resources**: CPU and memory allocations.  

Pods are **ephemeral** — if one fails, controllers (like **Deployments**) automatically recreate or reschedule new ones, maintaining the desired number of instances (e.g., three `nginx` Pods).

---

## Control Plane Components

The control plane manages the cluster through several key components:

- **kube-apiserver**: The primary API endpoint for all operations and commands (e.g., via `kubectl`). Handles authentication, validation, and communication.  
- **etcd**: A distributed key-value store maintaining the entire cluster’s configuration and state data.  
- **kube-scheduler**: Assigns unscheduled Pods to nodes based on resource availability and scheduling constraints.  
- **kube-controller-manager**: Runs controllers (like the Deployment controller) to reconcile desired vs. actual states.

**Nodes** run:  
- **kubelet**: The agent responsible for starting and managing Pods using a container runtime (e.g., `containerd`).  
- **kube-proxy**: Manages networking and load balancing across Pods.  
- **Pods**: The application workloads themselves.

---

## GKE Differences

**Google Kubernetes Engine (GKE)** simplifies Kubernetes management by handling much of the control plane for you.  

Key distinctions:  
- The **control plane** is managed and hidden; only the API endpoint is exposed.  
- **Autopilot Mode** automates node provisioning, scaling, upgrades, and security — ideal for managed operations.  
- **Standard Mode** gives more flexibility and control, requiring manual node management.

---
# Kubernetes Objects Explained

## 1. What Kubernetes Objects Are

Kubernetes uses **objects** to represent everything it manages — Pods, Services, Deployments, etc.  
Each object describes a **desired state**, such as _“I want three nginx servers running.”_

You define these objects using **manifest files**, which are text files typically written in **YAML** (though JSON also works). YAML files act as the instructions for Kubernetes.

Each manifest must include:

- **apiVersion** – The version of the Kubernetes API you’re using.  
- **kind** – The type of object (e.g., Pod, Deployment).  
- **metadata** – Basic information like the name, ID, and optional namespace.  
- **spec** – The desired state or configuration (like which containers to run and how many).

---

## 2. Identifying Objects

Every Kubernetes object has:

- **Name:** A unique name within a namespace (under 253 characters, using letters, numbers, hyphens, and periods).  
- **UID (Unique Identifier):** A unique ID automatically generated by Kubernetes; it remains unique over the cluster’s lifetime.  
- **Labels:** Key-value pairs that tag objects (e.g., `app: nginx`). Labels make it easier to organize and select groups of objects.

You can use **label selectors** in commands like:

```
kubectl get pods -l app=nginx
```

This fetches all Pods with the label `app=nginx`.

---

## 3. Pods vs. Controllers

A **Pod** is the smallest deployable unit in Kubernetes — it usually runs a single container or a group of closely related containers.

If you manually create three separate Pods to run nginx, you’ll have to manage each one yourself. That’s not efficient or reliable because **Pods are temporary** — they can fail, be rescheduled, or deleted.

Instead of manually managing Pods, Kubernetes uses **controllers** to automate and maintain the desired state.

---

## 4. Controllers and Deployments

A **controller** in Kubernetes watches over objects to ensure they match the desired state.  
If something fails, it fixes it automatically.

Common controller types include:

- **Deployment** – Manages stateless apps (like nginx web servers).  
- **StatefulSet** – Manages stateful apps (like databases).  
- **DaemonSet** – Ensures one Pod runs on every node.  
- **Job** – Runs tasks that complete once and exit.

### Example: nginx Deployment

For an nginx application, using a **Deployment** is ideal. Inside the Deployment YAML, you can specify:

- The number of **replicas** (how many Pods to maintain).  
- The **template** of the Pod (e.g., which container image to use).  
- Any **volumes**, environment variables, etc.

When you apply the Deployment:

1. The **Deployment controller** creates a **ReplicaSet**.  
2. The **ReplicaSet** creates and maintains the specified number of Pods.  
3. If a Pod fails, it’s automatically replaced.

You only maintain a **single YAML file**, and Kubernetes ensures the system continuously matches that definition.

---

## Summary

- **Kubernetes objects** like Pods represent desired states.  
- **YAML manifests** describe what those objects should look like.  
- **Controllers** (like Deployments) automatically maintain the desired state.  
- **Labels** and **namespaces** help organize and manage resources effectively.

# What is kubectl?

**kubectl** (pronounced *cube-control*) is the **command-line tool** used to manage and interact with **Kubernetes clusters**.

It’s like the remote control for your cluster — when you type a command, `kubectl` converts it into an **API request** that tells Kubernetes what you want to do.

For example:

```
kubectl get pods
```  

- `kubectl` translates that to an API call and sends it to the **Kubernetes API server**.  
- The API server processes it and responds.  
- `kubectl` displays the result back to you.

Think of Kubernetes as a *brain* that manages many containers; `kubectl` is how you communicate with that brain.

---

## Why is kubectl important?

`kubectl` is crucial because it allows administrators and developers to:

- Inspect cluster resources (like Pods, Deployments, Services, etc.)
- Deploy and manage applications
- Debug issues within running containers
- Configure settings and view cluster information

Without `kubectl`, interacting with or controlling a Kubernetes cluster from your terminal would be very difficult.

---

## How does kubectl connect to a cluster?

To use `kubectl`, it needs to know:

- **Where** the cluster is located (the cluster endpoint)
- **Who** you are (your credentials)
- **Which namespace/context** to use

That information is stored in a **config file** (usually at `~/.kube/config`).

In **Google Kubernetes Engine (GKE)**, you can generate these credentials using:

```
gcloud container clusters get-credentials CLUSTER_NAME
```

This command updates your kubeconfig file so `kubectl` can talk to your GKE cluster.

---

## Structure of a kubectl command

A typical command looks like this:
```
kubectl <command> <type> <name> [flags]
```
- **Command** → the action (e.g., `get`, `describe`, `apply`, `delete`)
- **Type** → the resource (e.g., `pods`, `deployments`, `services`)
- **Name** → the specific resource name (optional)
- **Flags** → extra modifiers (e.g., `-o yaml`, `--namespace`, etc.)

### Examples
```
kubectl get pods
kubectl describe pod my-app
kubectl get pod my-app -o yaml
```


---

## Common commands for introspection and debugging

When troubleshooting applications in a cluster, you can use:
```
kubectl get pods
```
> Shows Pod statuses (Running, Pending, Failed, CrashLoopBackOff)

kubectl describe pod <pod-name>


> Displays detailed information about a Pod and its containers
```
kubectl logs <pod-name>
```
> Views logs from containers in a Pod
```
kubectl exec -it <pod-name> -- /bin/bash
```

> Opens an interactive shell inside a container

This toolkit helps you understand *what’s happening* inside your cluster and *why* something might not be working.

---

## Summary

| Concept | Purpose |
|----------|----------|
| **kubectl** | Command-line tool for interacting with Kubernetes clusters. |
| **Kube API Server** | Main entry point for all cluster commands. `kubectl` communicates with this. |
| **Config file (~/.kube/config)** | Stores cluster info and credentials. |
| **gcloud get-credentials** | Creates/updates the kubeconfig for GKE clusters. |
| **Commands (get, describe, logs, exec)** | Used for viewing, managing, and debugging resources. |






# Kubernetes Default Namespaces Reference

Kubernetes automatically creates four default namespaces in every cluster. These provide essential system functions and a default space for user workloads.

## Namespace Summary

| Namespace       | Purpose                                              | Typical Contents                                   | Usage Notes                                      |
|-----------------|------------------------------------------------------|----------------------------------------------------|--------------------------------------------------|
| **default**     | Default namespace for user workloads when no namespace is specified | User deployments, services, pods                   | Always exists; use `-n default` explicitly if needed |
| **kube-node-lease** | Manages node heartbeats via lease objects            | Lease resources for node health checks             | Internal; updated every 10s by kubelet           |
| **kube-public** | Resources visible/readable by all users cluster-wide | ConfigMaps like cluster-info                       | Public read access; no auth required             |
| **kube-system** | Kubernetes system components                         | CoreDNS, kube-proxy, metrics-server, controller-manager | System-only; avoid modifying                     |

# Kubernetes `kube-node-lease` Explained

`kube-node-lease` is a dedicated Kubernetes namespace that manages **node heartbeats** through **Lease objects**, enabling efficient health checks for cluster nodes.

## Purpose and Functionality

- **Lease resources** in the `kube-node-lease` namespace represent lightweight heartbeats from each node.  
- For every Node in the cluster, a corresponding **Lease object** (with the same name) exists and is updated by the **kubelet** to signal node availability.  
- The **Kubernetes control plane** monitors the `spec.renewTime` timestamp in these Leases to detect if a node is healthy or failing, providing faster failure detection than traditional Node status updates.

## How It Works

1. **Kubelet updates:** Every **10 seconds** (default interval), the kubelet on each node sends an update to its Lease object in `kube-node-lease`, refreshing the `renewTime` field.  
2. **Internal mechanism:** These are system-internal objects; users rarely interact with them directly since they’re optimized for low overhead compared to full Node status patches.  
3. **Failure detection:** If `renewTime` expires (typically after **40 seconds lease duration**), the control plane marks the node as unavailable, triggering **eviction or rescheduling**.

## Viewing Node Leases

You can check node leases with the following commands:
```
kubectl get lease -n kube-node-lease
kubectl describe lease <node-name> -n kube-node-lease
```

Typical output shows `ownerReferences` linking back to the Node and recent `renewTime` information.

## Key Benefits

- Reduces **API server load** from frequent Node status updates.  
- Enables **rapid node health monitoring** in large clusters.  
- Part of the **Kubernetes Lease API** in `coordination.k8s.io/v1` used for distributed coordination.



- **Cordon the existing node pool**: This operation marks the nodes in the existing node pool (node) as unschedulable. Kubernetes stops scheduling new Pods to these nodes once you mark them as unschedulable.
- **Drain the existing node pool**: This operation evicts the workloads running on the nodes of the existing node pool (node) gracefully.
- **Pod Affinity** is used to ensure pods are scheduled on the same node, 
- **Pod Anti Affinity** is used to ensure pods are not scheduled on the same no


# Access cluster credentials
gcloud container clusters get-credentials hello-demo-cluster --zone "ZONE" 

# Resize existing node pool
gcloud container clusters resize hello-demo-cluster --node-pool my-node-pool --num-nodes 3 --zone "ZONE" 

# Create new optimized node pool
gcloud container node-pools create larger-pool --cluster=hello-demo-cluster --machine-type=e2-standard-2 --num-nodes=1 --zone="ZONE" 

# Delete node pool after migration
gcloud container node-pools delete my-node-pool --cluster hello-demo-cluster --zone "ZONE" 

# Create regional cluster
gcloud container clusters create regional-demo --region="REGION" --num-nodes=1 
# Scale deployments
kubectl scale deployment hello-server --replicas=2 

# Node pool migration workflow
for node in $(kubectl get nodes -l cloud.google.com/gke-nodepool=my-node-pool -o=name); do kubectl cordon "$node"; done 
for node in $(kubectl get nodes -l cloud.google.com/gke-nodepool=my-node-pool -o=name); do kubectl drain --force --ignore-daemonsets --delete-emptydir-data --grace-period=10 "$node"; d

# Pod management
kubectl get pods -o=wide 
kubectl apply -f pod-1.yaml 
kubectl get pod pod-1 pod-2 --output wide
kubectl exec -it pod-1 -- sh 
kubectl delete pod pod-2 


